{"ast":null,"code":"// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\nexport function dfs(grid,startNode,finishNode){var visitedNodesInOrder=[];var nextNodesStack=[];nextNodesStack.push(startNode);while(nextNodesStack.length){var currentNode=nextNodesStack.pop();if(currentNode===finishNode){return visitedNodesInOrder;}if(!currentNode.isWall&&(currentNode.isStart||!currentNode.isVisited)){currentNode.isVisited=true;visitedNodesInOrder.push(currentNode);var col=currentNode.col,row=currentNode.row;var nextNode=void 0;if(row>0){nextNode=grid[row-1][col];if(!nextNode.isVisited){nextNode.previousNode=currentNode;nextNodesStack.push(nextNode);}}if(row<grid.length-1){nextNode=grid[row+1][col];if(!nextNode.isVisited){nextNode.previousNode=currentNode;nextNodesStack.push(nextNode);}}if(col>0){nextNode=grid[row][col-1];if(!nextNode.isVisited){nextNode.previousNode=currentNode;nextNodesStack.push(nextNode);}}if(col<grid[0].length-1){nextNode=grid[row][col+1];if(!nextNode.isVisited){nextNode.previousNode=currentNode;nextNodesStack.push(nextNode);}}}}}","map":{"version":3,"sources":["C:\\Users\\SAMRIDHI SAHU\\code\\PastWork\\code\\optimal path finder\\nodejs\\src\\algorithms\\dfs.js"],"names":["dfs","grid","startNode","finishNode","visitedNodesInOrder","nextNodesStack","push","length","currentNode","pop","isWall","isStart","isVisited","col","row","nextNode","previousNode"],"mappings":"AAAA;AACA;AACA;AAEA,MAAO,SAASA,CAAAA,GAAT,CAAaC,IAAb,CAAmBC,SAAnB,CAA8BC,UAA9B,CAA0C,CAC/C,GAAMC,CAAAA,mBAAmB,CAAG,EAA5B,CACA,GAAMC,CAAAA,cAAc,CAAG,EAAvB,CACAA,cAAc,CAACC,IAAf,CAAoBJ,SAApB,EACA,MAAOG,cAAc,CAACE,MAAtB,CAA8B,CAC5B,GAAMC,CAAAA,WAAW,CAAGH,cAAc,CAACI,GAAf,EAApB,CAEA,GAAID,WAAW,GAAKL,UAApB,CAAgC,CAC9B,MAAOC,CAAAA,mBAAP,CACD,CAED,GACE,CAACI,WAAW,CAACE,MAAb,GACCF,WAAW,CAACG,OAAZ,EAAuB,CAACH,WAAW,CAACI,SADrC,CADF,CAGE,CACAJ,WAAW,CAACI,SAAZ,CAAwB,IAAxB,CACAR,mBAAmB,CAACE,IAApB,CAAyBE,WAAzB,EAFA,GAIOK,CAAAA,GAJP,CAImBL,WAJnB,CAIOK,GAJP,CAIYC,GAJZ,CAImBN,WAJnB,CAIYM,GAJZ,CAKA,GAAIC,CAAAA,QAAQ,OAAZ,CACA,GAAID,GAAG,CAAG,CAAV,CAAa,CACXC,QAAQ,CAAGd,IAAI,CAACa,GAAG,CAAG,CAAP,CAAJ,CAAcD,GAAd,CAAX,CACA,GAAI,CAACE,QAAQ,CAACH,SAAd,CAAyB,CACvBG,QAAQ,CAACC,YAAT,CAAwBR,WAAxB,CACAH,cAAc,CAACC,IAAf,CAAoBS,QAApB,EACD,CACF,CACD,GAAID,GAAG,CAAGb,IAAI,CAACM,MAAL,CAAc,CAAxB,CAA2B,CACzBQ,QAAQ,CAAGd,IAAI,CAACa,GAAG,CAAG,CAAP,CAAJ,CAAcD,GAAd,CAAX,CACA,GAAI,CAACE,QAAQ,CAACH,SAAd,CAAyB,CACvBG,QAAQ,CAACC,YAAT,CAAwBR,WAAxB,CACAH,cAAc,CAACC,IAAf,CAAoBS,QAApB,EACD,CACF,CACD,GAAIF,GAAG,CAAG,CAAV,CAAa,CACXE,QAAQ,CAAGd,IAAI,CAACa,GAAD,CAAJ,CAAUD,GAAG,CAAG,CAAhB,CAAX,CACA,GAAI,CAACE,QAAQ,CAACH,SAAd,CAAyB,CACvBG,QAAQ,CAACC,YAAT,CAAwBR,WAAxB,CACAH,cAAc,CAACC,IAAf,CAAoBS,QAApB,EACD,CACF,CACD,GAAIF,GAAG,CAAGZ,IAAI,CAAC,CAAD,CAAJ,CAAQM,MAAR,CAAiB,CAA3B,CAA8B,CAC5BQ,QAAQ,CAAGd,IAAI,CAACa,GAAD,CAAJ,CAAUD,GAAG,CAAG,CAAhB,CAAX,CACA,GAAI,CAACE,QAAQ,CAACH,SAAd,CAAyB,CACvBG,QAAQ,CAACC,YAAT,CAAwBR,WAAxB,CACAH,cAAc,CAACC,IAAf,CAAoBS,QAApB,EACD,CACF,CACF,CACF,CACF","sourcesContent":["// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const nextNodesStack = [];\r\n  nextNodesStack.push(startNode);\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.pop();\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}